'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.state = undefined;
exports.navigate = navigate;

var _getOrderedTools = require('../util/getOrderedTools');

var _getOrderedTools2 = _interopRequireDefault(_getOrderedTools);

var _defaultLayoutRouter = require('../defaultLayoutRouter');

var _defaultLayoutRouter2 = _interopRequireDefault(_defaultLayoutRouter);

var _location = require('part:@sanity/base/location');

var _location2 = _interopRequireDefault(_location);

var _reconfigureClient = require('../util/reconfigureClient');

var _reconfigureClient2 = _interopRequireDefault(_reconfigureClient);

var _spaces = require('../util/spaces');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function resolveUrlStateWithDefaultSpace(state) {
  if (!_spaces.HAS_SPACES || !state || state.space) {
    return state;
  }
  const defaultSpace = _spaces.CONFIGURED_SPACES.find(ds => ds.default) || _spaces.CONFIGURED_SPACES[0];
  return Object.assign({}, state, { space: defaultSpace.name });
}

function resolveUrlStateWithDefaultTool(state) {
  if (!state || state.tool) {
    return state;
  }
  return Object.assign({}, state, {
    tool: (0, _getOrderedTools2.default)()[0].name
  });
}

function makeBackwardsCompatible(state) {
  if (!state) {
    return state;
  }
  if ((0, _getOrderedTools2.default)().find(tool => tool.name === state.space)) {
    return Object.assign({}, state, { tool: state.space, space: undefined });
  }
  return state;
}

function resolveDefaultState(state) {
  const urlStateWithDefaultTool = resolveUrlStateWithDefaultTool(makeBackwardsCompatible(state));
  return _spaces.HAS_SPACES ? resolveUrlStateWithDefaultSpace(urlStateWithDefaultTool) : urlStateWithDefaultTool;
}

function resolveIntentState(currentState, intentState) {
  const intent = intentState.intent,
        params = intentState.params;


  const tools = (0, _getOrderedTools2.default)();

  const currentTool = currentState.tool ? tools.find(tool => tool.name === currentState.tool) : null;

  // If current tool can handle intent and if so, give it precedence
  const matchingTool = (currentTool ? [currentTool, ...tools] : tools).find(tool => tool && typeof tool.canHandleIntent === 'function' && tool.canHandleIntent(intent, params));

  if (matchingTool) {
    const toolState = matchingTool.getIntentState(intent, params);
    const currentWithState = resolveUrlStateWithDefaultSpace(currentState) || currentState;
    return Object.assign({}, currentWithState, {
      tool: matchingTool.name,
      [matchingTool.name]: toolState
    });
  }
  return {
    isNotFound: true,
    intent: { name: intent, params }
  };
}

function maybeHandleIntent(prevEvent, currentEvent) {
  if (currentEvent && currentEvent.state && currentEvent.state.intent) {
    const redirectState = resolveIntentState(prevEvent ? prevEvent.state : {}, currentEvent.state);
    if (redirectState) {
      navigate(_defaultLayoutRouter2.default.encode(redirectState), { replace: true });
      return null;
    }
  }
  return currentEvent;
}

function decodeUrlState(locationEvent) {
  return {
    type: locationEvent.type,
    state: _defaultLayoutRouter2.default.decode(location.pathname),
    isNotFound: _defaultLayoutRouter2.default.isNotFound(location.pathname)
  };
}

function maybeRedirectDefaultState(event) {
  const redirectState = resolveDefaultState(event.state);
  if (redirectState !== event.state) {
    navigate(_defaultLayoutRouter2.default.encode(redirectState), { replace: true });
    return null;
  }
  return event;
}

function navigate(newUrl, options) {
  _location2.default.actions.navigate(newUrl, options);
}

const state = exports.state = _location2.default.state.map(decodeUrlState).scan(maybeHandleIntent, null).filter(Boolean).map(maybeRedirectDefaultState).filter(Boolean).publishReplay(1).refCount();

if (_spaces.HAS_SPACES) {
  // Uglybugly mutation ahead.
  state.map(event => event.state).filter(Boolean).do(_reconfigureClient2.default).subscribe();
}