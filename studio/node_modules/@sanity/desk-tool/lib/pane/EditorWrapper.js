'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _throttle2 = require('lodash/throttle');

var _throttle3 = _interopRequireDefault(_throttle2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
// Connects the FormBuilder with various sanity roles


var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

var _validation = require('@sanity/validation');

var _promiseLatest = require('promise-latest');

var _promiseLatest2 = _interopRequireDefault(_promiseLatest);

var _formBuilder = require('part:@sanity/form-builder');

var _formBuilder2 = _interopRequireDefault(_formBuilder);

var _schema = require('part:@sanity/base/schema');

var _schema2 = _interopRequireDefault(_schema);

var _default = require('part:@sanity/components/buttons/default');

var _default2 = _interopRequireDefault(_default);

var _client = require('part:@sanity/base/client');

var _client2 = _interopRequireDefault(_client);

var _draftUtils = require('../utils/draftUtils');

var _Editor = require('./Editor');

var _Editor2 = _interopRequireDefault(_Editor);

var _EditorWrapper = require('./styles/EditorWrapper.css');

var _EditorWrapper2 = _interopRequireDefault(_EditorWrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const INITIAL_DOCUMENT_STATE = {
  isLoading: true,
  deletedSnapshot: null,
  snapshot: null
};

const INITIAL_STATE = {
  isSaving: true,
  isReconnecting: false,
  isCreatingDraft: false,
  transactionResult: null,
  validationPending: true,
  draft: INITIAL_DOCUMENT_STATE,
  published: INITIAL_DOCUMENT_STATE
};

function documentEventToState(event) {
  switch (event.type) {
    case 'rebase':
    case 'create':
    case 'createIfNotExists':
    case 'snapshot':
      {
        return {
          deletedSnapshot: null,
          snapshot: event.document
        };
      }
    case 'mutation':
      {
        return {
          deletedSnapshot: event.deletedSnapshot,
          snapshot: event.document ? _extends({}, event.document, {
            // todo: The following line is a temporary workaround for a problem with the mutator not
            // setting updatedAt on patches applied optimistic when they are received from server
            // can be removed when this is fixed
            _updatedAt: new Date().toISOString()
          }) : event.document
        };
      }
    case 'reconnect':
      {
        return {};
      }
    default:
      {
        // eslint-disable-next-line no-console
        console.log('Unhandled document event type "%s"', event.type, event);
        return {};
      }
  }
}

function exists(draft, published) {
  return draft.snapshot || published.snapshot;
}

function isRecoverable(draft, published) {
  return !exists(draft, published) && (draft.deletedSnapshot || published.deletedSnapshot);
}

class EditorWrapper extends _react2.default.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), _initialiseProps.call(this), _temp;
  }

  setup(documentId) {
    this.dispose();
    this.published = (0, _formBuilder.checkout)((0, _draftUtils.getPublishedId)(documentId));
    this.draft = (0, _formBuilder.checkout)((0, _draftUtils.getDraftId)(documentId));
    this.validateLatestDocument = (0, _debounce3.default)((0, _promiseLatest2.default)(this.validateDocument, 300));

    this.subscription = this.published.events.map(event => _extends({}, event, { version: 'published' })).merge(this.draft.events.do(this.receiveDraftEvent).map(event => _extends({}, event, { version: 'draft' }))).subscribe(event => {
      this.setState(prevState => {
        const version = event.version; // either 'draft' or 'published'
        return {
          validationPending: true,
          [version]: _extends({}, prevState[version] || {}, documentEventToState(event), {
            isLoading: false
          })
        };
      }, this.validateLatestDocument);
    });
  }

  getDraftId() {
    return (0, _draftUtils.getDraftId)(this.props.documentId);
  }

  getPublishedId() {
    return (0, _draftUtils.getPublishedId)(this.props.documentId);
  }

  componentDidMount() {
    this._isMounted = true;
    this.setup(this.props.documentId);
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.documentId !== this.props.documentId) {
      this.setState(INITIAL_STATE);
      this.setup(nextProps.documentId);
    }
  }

  componentWillUnmount() {
    this._isMounted = false;

    // Cancel throttled commit since draft will be nulled on unmount
    this.commit.cancel();

    // Instead, explicitly commit
    this.draft.commit().subscribe(() => {
      // todo: error handling
    });

    this.dispose();
  }

  dispose() {
    if (this.subscription) {
      this.subscription.unsubscribe();
      this.subscription = null;
    }

    if (this.validateLatestDocument) {
      this.validateLatestDocument.cancel();
      this.validateLatestDocument = null;
    }

    this.published = null;
    this.draft = null;
  }

  renderDeleted() {
    return _react2.default.createElement(
      'div',
      { className: _EditorWrapper2.default.deletedDocument },
      _react2.default.createElement(
        'div',
        { className: _EditorWrapper2.default.deletedDocumentInner },
        _react2.default.createElement(
          'h3',
          null,
          'This document just got deleted'
        ),
        _react2.default.createElement(
          'p',
          null,
          'You can undo deleting it until you close this window/tab'
        ),
        _react2.default.createElement(
          _default2.default,
          { onClick: this.handleRestoreDeleted },
          'Undo delete'
        )
      )
    );
  }

  render() {
    const typeName = this.props.typeName;
    var _state = this.state;
    const draft = _state.draft,
          published = _state.published,
          markers = _state.markers,
          isCreatingDraft = _state.isCreatingDraft,
          isUnpublishing = _state.isUnpublishing,
          transactionResult = _state.transactionResult,
          isPublishing = _state.isPublishing,
          isSaving = _state.isSaving,
          validationPending = _state.validationPending,
          isReconnecting = _state.isReconnecting;


    if (isRecoverable(draft, published)) {
      return this.renderDeleted();
    }

    return _react2.default.createElement(_Editor2.default, {
      patchChannel: this.patchChannel,
      type: _schema2.default.get(typeName),
      published: published.snapshot,
      draft: draft.snapshot,
      markers: markers,
      validationPending: validationPending,
      isLoading: draft.isLoading || published.isLoading,
      isSaving: isSaving,
      isReconnecting: isReconnecting,
      isPublishing: isPublishing,
      isUnpublishing: isUnpublishing,
      transactionResult: transactionResult,
      isCreatingDraft: isCreatingDraft,
      onDelete: this.handleDelete,
      onClearTransactionResult: this.handleClearTransactionResult,
      onDiscardDraft: this.handleDiscardDraft,
      onPublish: this.handlePublish,
      onUnpublish: this.handleUnpublish,
      onChange: this.handleChange
    });
  }
}
exports.default = EditorWrapper;
EditorWrapper.propTypes = {
  documentId: _propTypes2.default.string.isRequired,
  typeName: _propTypes2.default.string.isRequired
};

var _initialiseProps = function _initialiseProps() {
  var _this = this;

  this.state = INITIAL_STATE;
  this.patchChannel = _formBuilder2.default.createPatchChannel();
  this.validateDocument = _asyncToGenerator(function* () {
    var _state2 = _this.state;
    const draft = _state2.draft,
          published = _state2.published;

    const doc = draft && draft.snapshot || published && published.snapshot;
    if (!doc || !doc._type) {
      return [];
    }

    const type = _schema2.default.get(doc._type);
    if (!type) {
      // eslint-disable-next-line no-console
      console.warn('Schema for document type "%s" not found, skipping validation');
      return [];
    }

    const markers = yield (0, _validation.validateDocument)(doc, _schema2.default);
    _this.setStateIfMounted({ markers, validationPending: false });
    return markers;
  });

  this.receiveDraftEvent = event => {
    this.setState({ isReconnecting: event.type === 'reconnect' });
    if (event.type !== 'mutation') {
      return;
    }
    // Broadcast incoming patches to input components that applies patches on their own
    // Note: This is *experimental*
    this.patchChannel.receivePatches({
      patches: event.patches,
      snapshot: event.document
    });
  };

  this.handleDiscardDraft = () => {
    this.draft.delete();
    this.draft.commit().subscribe(() => {
      // todo: error handling
    });
  };

  this.handleDelete = () => {
    const documentId = this.props.documentId;

    const tx = _client2.default.observable.transaction().delete((0, _draftUtils.getPublishedId)(documentId)).delete((0, _draftUtils.getDraftId)(documentId));

    _observable2.default.from(tx.commit()).map(result => ({
      type: 'success',
      result: result
    })).catch(error => _observable2.default.of({
      type: 'error',
      message: `An error occurred while attempting to delete document.
        This usually means that you attempted to delete a document that other documents
        refers to.`,
      error
    })).subscribe(result => {
      this.setStateIfMounted({ transactionResult: result });
    });
  };

  this.handleClearTransactionResult = () => {
    this.setStateIfMounted({ transactionResult: null });
  };

  this.handleUnpublish = () => {
    const documentId = this.props.documentId;
    const published = this.state.published;


    let tx = _client2.default.observable.transaction().delete((0, _draftUtils.getPublishedId)(documentId));

    if (published.snapshot) {
      tx = tx.createIfNotExists(_extends({}, (0, _omit3.default)(published.snapshot, '_updatedAt'), {
        _id: (0, _draftUtils.getDraftId)(documentId)
      }));
    }

    _observable2.default.from(tx.commit()).map(result => ({
      type: 'success',
      result: result
    })).catch(error => _observable2.default.of({
      type: 'error',
      message: `An error occurred while attempting to unpublish document.
        This usually means that you attempted to unpublish a document that other documents
        refers to.`,
      error
    })).subscribe(result => {
      this.setStateIfMounted({ transactionResult: result });
    });
  };

  this.handlePublish = () => {
    const documentId = this.props.documentId;
    var _state3 = this.state;
    const draft = _state3.draft,
          published = _state3.published;

    this.setState({ isPublishing: true });

    const tx = _client2.default.observable.transaction();

    if (!published || !published.snapshot) {
      // If the document has not been published, we want to create it - if it suddenly exists
      // before being created, we don't want to overwrite if, instead we want to yield an error
      tx.create(_extends({}, (0, _omit3.default)(draft.snapshot, '_updatedAt'), {
        _id: (0, _draftUtils.getPublishedId)(documentId)
      }));
    } else {
      // If it exists already, we only want to update it if the revision on the remote server
      // matches what our local state thinks it's at
      tx.patch((0, _draftUtils.getPublishedId)(documentId), {
        // Hack until other mutations support revision locking
        unset: ['_reserved_prop_'],
        ifRevisionID: published.snapshot._rev
      }).createOrReplace(_extends({}, (0, _omit3.default)(draft.snapshot, '_updatedAt'), {
        _id: (0, _draftUtils.getPublishedId)(documentId)
      }));
    }

    tx.delete((0, _draftUtils.getDraftId)(documentId));

    // @todo add error handling for revision mismatch
    _observable2.default.from(tx.commit()).map(result => ({
      type: 'success',
      result: result
    })).catch(error => _observable2.default.of({
      type: 'error',
      message: 'An error occurred while attempting to publishing document',
      error
    })).subscribe({
      next: result => {
        this.setState({
          transactionResult: result
        });
      },
      complete: () => {
        this.setStateIfMounted({ isPublishing: false });
      }
    });
  };

  this.handleChange = event => {
    var _state4 = this.state;
    const published = _state4.published,
          draft = _state4.draft;
    const typeName = this.props.typeName;


    if (!draft.snapshot) {
      this.draft.createIfNotExists(_extends({}, (0, _omit3.default)(published.snapshot, '_updatedAt'), {
        _id: this.getDraftId(),
        _type: typeName
      }));
    }

    this.draft.patch(event.patches);
    this.commit();
  };

  this.setStateIfMounted = (...args) => {
    if (!this._isMounted) {
      return;
    }

    this.setState(...args);
  };

  this.commit = (0, _throttle3.default)(() => {
    this.setStateIfMounted({ isSaving: true });
    this.draft.commit().subscribe({
      next: () => {
        // todo
      },
      error: _error => {
        // todo
      },
      complete: () => {
        this.setStateIfMounted({ isSaving: false });
      }
    });
  }, 1000, { leading: true, trailing: true });

  this.handleRestoreDeleted = () => {
    var _state5 = this.state;
    const draft = _state5.draft,
          published = _state5.published;


    const commits = [];
    if (draft.deletedSnapshot) {
      this.draft.createIfNotExists(draft.deletedSnapshot);
      commits.push(this.draft.commit());
    } else if (published.deletedSnapshot) {
      this.published.createIfNotExists(published.deletedSnapshot);
      commits.push(this.published.commit());
    }
    commits.forEach(c => {
      c.subscribe({
        next: () => {}
      });
    });
  };
};